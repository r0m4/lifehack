var Util = require('./myutils'),
MultiWait = require('./multiwait'),
DelayedValue = require('./delayed_value'),
Emitter = require('events').EventEmitter

function DelayedResponse() {
	Emitter.call(this)
	this.stack = []
	this.multiwait = new MultiWait
}
Util.inherits(DelayedResponse, Emitter)

DelayedResponse.prototype.push = function(value) {
	var self = this
	if (value && typeof(value.on) === 'function') {
		if (typeof(value.flatten) !== 'function')
			value = new DelayedValue(value)
	}
	this.stack.push(value)
}

DelayedResponse.prototype.unshift = function(value) {
	this.stack.unshift(value)
}

DelayedResponse.prototype.flatten = function() {
	var result = ''
	for (var i=0; i<this.stack.length; i++) {
		var elem = this.stack[i]
		if (elem && typeof(elem.flatten) === 'function') {
			try {
				result = result + elem.flatten()
			} catch(e) {
				console.log("Flatten error: " + e.message)
			}
		} else {
			result = result + elem
		}
	}
	return result
}

DelayedResponse.prototype.on = function() {
	var self = this
	Emitter.prototype.on.apply(this, arguments)

	for (var i=0; i<this.stack.length; i++) {
		var value = this.stack[i]
		if (value && typeof(value.on) === 'function') {
			this.multiwait.addPending()
			value.on('ready', function() {
				self.multiwait.finishPending()
			})
		}
	}


	this.multiwait.waitall(function() {
		self.emit('ready', self.flatten())
	})
}

module.exports = DelayedResponse
